<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
		<meta charset='utf-8' /> 
		<title>kcgi | minimal CGI library for C</title>
		<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?skin=sons-of-obsidian"></script>
		<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" />
		<link rel="stylesheet" href="index.css" type="text/css" />
		<script>
			function showComments() 
			{
				var show, nshow;

				show = document.getElementById('comments');
				noshow = document.getElementById('nocomments');

				console.log('maxheight = ' + show.style.maxHeight);

				if (show.style.maxHeight == '' || show.style.maxHeight == '0px') {
					show.style.maxHeight = '100em';
					show.style.padding = '1em';
					noshow.style.maxHeight = 0;
					noshow.style.padding = 0;
				} else {
					show.style.maxHeight = 0;
					show.style.padding = 0;
					noshow.style.maxHeight = '100em';
					noshow.style.padding = '1em';
				}
			}
		</script>
	</head>
	<body itemscope="itemscope" itemtype="http://schema.org/SoftwareApplication">
		<header>
			<section id="header">
				<h1>
					<span itemprop="name" class="nm">kcgi</span> 
					&#8211; 
					<span itemprop="description" class="nd">minimal CGI library in C</span>
				</h1>
				<nav>
					<a itemprop="downloadURL" href="snapshots/kcgi.tgz"><i class="fa fa-fw fa-gears"></i></a>
					<a href="snapshots/kcgi.tgz.sha512"><i class="fa fa-fw fa-lock"></i></a>
					<a href="snapshots"><i class="fa fa-fw fa-archive"></i></a>
				</nav>
			</section>
			<section id="version">
				<nav data-sblg-nav="1" data-sblg-navsz="3" data-sblg-navcontent="1">
					Version <span class="version">${sblg-title}</span> (<time datetime="${sblg-date}">${sblg-date}</time>): ${sblg-aside}
				</nav>
			</section>
		</header>
		<article>
			<section id="intro">
				<p>
					<span class="nm">kcgi</span> is a minimal CGI library for web applications in <a
						href="http://opensource.org/licenses/ISC" rel="license">ISC licensed</a> ISO C.  
					It was designed to be secure and auditable.
					To start, download <a href="snapshots/kcgi.tgz">kcgi.tgz</a> and run <code>make install</code> into your
					<code>PREFIX</code> of choice, then read <a href="kcgi.3.html">kcgi(3)</a>.
					The system also ships with the <a href="kcgihtml.3.html">kcgihtml(3)</a>, <a
						href="kcgijson.3.html">kcgijson(3)</a>, <a href="kcgixml.3.html">kcgixml(3)</a>, and <a
						href="kcgi_regress.3.html">kcgi_regress(3)</a> libraries.
					Contact <a href="http://kristaps.bsd.lv">Kristaps</a> with questions or comments.
					<span class="nm">kcgi</span> is a <a href="http://www.bsd.lv">BSD.lv</a> project.
				</p>
			</section>
			<figure id="sample">
				<figcaption>
					<span>Figure</span>: this simple example implements a server that just echoes <q>Hello, World!</q> as an HTTP
					response.
				</figcaption>
				<pre id="nocomments" class="prettyprint linenums">#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;<a href="kcgi.3.html">kcgi.h</a>&gt;

int main(void) {
  struct kreq r;
  const char *page = "index";
  if (KCGI_OK != <a href="khttp_parse.3.html">khttp_parse</a>(&amp;r, NULL, 0, &amp;page, 1, 0))
    return(EXIT_FAILURE);
  <a href="khttp_head.3.html">khttp_head</a>(&amp;r, kresps[KRESP_STATUS], "%s", khttps[KHTTP_200]);
  khttp_head(&amp;r, kresps[KRESP_CONTENT_TYPE], "%s", kmimetypes[r.mime]);
  <a href="khttp_body.3.html">khttp_body</a>(&amp;r);
  <a href="khttp_write.3.html">khttp_puts</a>(&amp;r, &quot;Hello, world!&quot;);
  <a href="khttp_free.3.html">khttp_free</a>(&amp;r);
  return(EXIT_SUCCESS);
}</pre>
				<pre id="comments" class="prettyprint linenums">#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;<a href="kcgi.3.html">kcgi.h</a>&gt;

int main(void) {
  struct kreq r;
  const char *page = "index";

  /*
   * Parse the HTTP environment.
   * We only know a single page, "index", which is also
   * the default page if none is supplied.
   * (We don't validate any input fields.)
   */
  if (KCGI_OK != <a href="khttp_parse.3.html">khttp_parse</a>(&amp;r, NULL, 0, &amp;page, 1, 0))
    return(EXIT_FAILURE);

  /* 
   * Ordinarily, here I'd switch on the method (OPTIONS, etc.,
   * defined in the <q>method</q> variable) then switch on which
   * page was requested (<q>page</q> variable).
   * But for the same of example, just output a response.
   */

  /* Emit the HTTP status 200 header: everything's ok. */
  <a href="khttp_head.3.html">khttp_head</a>(&amp;r, kresps[KRESP_STATUS], "%s", khttps[KHTTP_200]);
  /* Echo our content-type, defaulting to HTML if none was specified. */
  khttp_head(&amp;r, kresps[KRESP_CONTENT_TYPE], "%s", kmimetypes[r.mime]);
  /* No more HTTP headers: start the HTTP document body. */
  <a href="khttp_body.3.html">khttp_body</a>(&amp;r);
  
  /*
   * We can put any content below here: JSON, HTML, etc.
   * Usually we'd switch on our MIME type.
   * However, we're just going to put the literal string as noted...
   */
  <a href="khttp_write.3.html">khttp_puts</a>(&amp;r, &quot;Hello, world!&quot;);
  /* Flush the document and free resources. */
  <a href="khttp_free.3.html">khttp_free</a>(&amp;r);
  return(EXIT_SUCCESS);
}</pre>
				<nav>
					<a href="#" onclick="showComments(); return false;"><i class="fa fa-comments"></i> Toggle comments</a>
				</nav>
			</figure>
			<section id="features">
				<h2>
					How does it work?
				</h2>
				<p>
					The meat of <span class="nm">kcgi</span> lies in the <a href="khttp_parse.3.html">khttp_parse(3)</a>
					function, which parses key-value input pairs from the HTTP request as well as determing the page
					request itself, MIME type, and so on.
					Application developers must invoke this function before all others.
					As mentioned in <a href="#security">security</a> section, the subroutines of 
					<a href="khttp_parse.3.html">khttp_parse(3)</a> are invoked inside of a sandboxed child process &#8211;
					this isolates unvalidated, adversarial input.
					It must be matched by an <a href="khttp_free.3.html">khttp_free(3)</a>.
				</p>
				<p>
					Once <a href="khttp_parse.3.html">khttp_parse(3)</a> has been successfully invoked, the calling
					application is free to respond to the parsed and validated request.
				</p>
				<h3 id="security">
					Security
				</h3>
				<p>
					As a security precaution, the <span class="nm">kcgi</span> library parses and validates untrusted
					network data in a sandboxed child process by forking within <a
						href="khttp_parse.3.html">khttp_parse(3)</a>, where child process is responsible for reading and
					parsing form data from the web server.
					This parsed data is returned to the parent process over a socket.
					This method of sandboxing the untrusted child process follows <a href="http://www.openssh.org">OpenSSH</a>, 
					and requires special handling for each operating system:
				</p>
				<dl>
					<dt>
						<a href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man4/systrace.4">systrace(4)</a>
						(<a href="http://www.openbsd.org">OpenBSD</a>)
					</dt>
					<dd>
						This requires the existence of <i>/dev/systrace</i> if running in a
						<code>chroot(2)</code>, which is strongly suggested.
						If you're using a stock <a href="http://www.openbsd.org">OpenBSD</a>, make sure that the
						mount-point of <i>/dev/systrace</i> isn't mounted <code>nodev</code>!
					</dd>
					<dt>
						<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/sandbox_init.3.html">sandbox_init(3)</a>
						(<a href="https://www.apple.com/osx/">Apple OSX</a>)
					</dt>
					<dd>
						This uses the sandboxing profile for <q>pure computation</q> as provided in Mac OS X Leopard and
						later.
						This is supplemented by resource limiting via <code>setrlimit(2)</code>.
					</dd>
					<dt>
						<a href="https://www.freebsd.org/cgi/man.cgi?query=capsicum&amp;sektion=4">capsicum(4)</a>
						(<a href="https://www.freebsd.org">FreeBSD</a>)
					</dt>
					<dd>
						Uses the capabilities facility on <a href="http://www.freebsd.org">FreeBSD</a> 10 and later.
						This is supplemented by resource limiting with <code>setrlimit(2)</code>.
					</dd>
				</dl>
				<p>
					Since validation occurs within the sandbox, special care must be taken that validation routines don't
					access the environment (e.g., by opening files, network connections, etc.), as the child will be
					abruptly killed by the sandbox facility.
					If required, this kind of validation can take place after the parse validation sequence.
				</p>
				<h3 id="portability">
					Portability
				</h3>
				<p>
					<span class="nm">kcgi</span> should run on any modern UNIX systems and with any web server.
					To date, it has been built and run on GNU/<a href="http://www.linux.org">Linux</a> machines, BSD (<a
						href="http://www.openbsd.org">OpenBSD</a>, <a href="http://www.freebsd.org">FreeBSD</a>), and <a href="http://www.apple.com/osx">Mac OSX</a>
					(Snow Leopard, Lion) on i386 and AMD64.
					It has been deployed under <a href="https://httpd.apache.org/">Apache</a>, <a
						href="http://nginx.org">nginx</a>, and OpenBSD's <a
						href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man8/httpd.8?query=httpd">httpd(8)</a>
						(the latter two via the <code>slowcgi</code> wrapper).
				</p>
				<p>
					Portability across UNIX systems is made possible by a small <code>configure</code> script that checks
					for minor inconsistencies such as <code>strlcpy(3)</code>, the <a href="#security">Security</a> mechanisms,
					and for <a href="#compression">Compression</a> support.
				</p>
				<h3 id="extending">
					Extensibility
				</h3>
				<p>
					While page maps and input validation are entirely driven by the interfacing application, <span
						class="nm">kcgi</span> also allows for extension of the default HTTP headers, schemas, MIME
					types, and so on.
					Reasonable default have been provided for convenience.
					For specifics, see <a href="khttp_parse.3.html">khttp_parse(3)</a>.
				</p>
				<p>
					The library can also be extended for different output modes.
					Two such modes, <a href="kcgihtml.3.html">kcgihtml(3)</a> and <a href="kcgijson.3.html">kcgijson(3)</a>,
					are bundled with the system.
					It allows a mechanism for building HTML5 trees around the usual
					<a href="khttp_write.3.html">khttp_write(3)</a> family of functions.
				</p>
				<h3 id="compression">
					Compression
				</h3>
				<p>
					If <code>HAVE_ZLIB</code> is enabled during compilation (via the <a href="#portability">Portability</a>
					mechanism), <a href="khttp_body.3.html">khttp_body(3)</a> will signal use of <a
						href="http://www.zlib.net">zlib</a> to compress the HTTP body.
					Compression is only enabled if the client provides the correct (<q>gzip</q>) HTTP request header.
				</p>
				<h3 id="input">
					Input Processing
				</h3>
				<p>
					All common input methods&#8212;query string, cookie, and form (multipart form-data and mixed,
					urlencoded, and plain&#8212;are supported by <span class="nm">kcgi</span>.
					As described in the <a href="#security">Security</a> section, these fields are all parsed and validated
					from network data in a child process.
					Each input key-value pair can be matched (by key name) to a validator, which is run when fields are
					parsed.
					You can then look up key-value pairs constant-time in a table indexed by that key.
				</p>
				<h3 id="template">
					Templating
				</h3>
				<p>
					Many application will want just to fill in an output template instead of creating complex output trees
					(relegating most work to JavaScript and JSON).
					<span class="nm">kcgi</span> provides the <a href="khttp_template.3.html">khttp_template(3)</a> family
					of functions to fill in files or memory buffers with data.
					Templates are the most common usage of <span class="nm">kcgi</span>, as they allow for a strong
					disconnect between prsentation and logic.
				</p>
				<h3 id="testing">
					Testing
				</h3>
				<p>
					<span class="nm">kcgi</span> is shipped with a fully automated testing framework executed with
					<code>make regress</code>.
					Interfacing systems can also make use of this by working with the <a
						href="kcgi_regress.3.html">kcgi_regress(3)</a> function library.
					This framework acts as a mini-webserver, listening on a local port, translating an HTTP document into a
					minimal CGI request, and passing the request to a <span class="nm">kcgi</span> CGI client.
					For internal tests, test requests are constructed with <a
						href="http://curl.haxx.se/libcurl/">libcurl</a>.
				</p>
				<p>
					The automated test framework, at the moment, only has a few tests for basic functionality and
					sandboxing.
					The binding local port is fixed, too; so if you plan on running the regression suite, you may need to
					tweak its access port.
				</p>
				<p>
					Another testing framework exists for use with the <a href="http://lcamtuf.coredump.cx/afl/">American
						fuzzy lop</a>.
					To use this, you'll need to compile the <code>make afl</code> target with your compiler of choice, e.g.,
					<code>make clean</code>, then <code>make afl CC=afl-gcc</code>.
					Then run the <code>afl-fuzz</code> tool on the <code>afl-multipart</code>, <code>afl-plain</code>, and
					<code>afl-urlencoded</code> binaries using the test cases (and dictionaries, for the first) provided.
				</p>
			</section>
		</article>
		<footer>
			<div>&#169; 2014 <a rel="author" href="http://kristaps.bsd.lv">Kristaps Dzonsons</a></div>
			<div>
				<i class="fa fa-clock-o"></i> $Date$
				<a href="snapshots/kcgi.tgz"><i class="fa fa-fw fa-gears"></i></a>
				<a href="snapshots/kcgi.tgz.sha512"><i class="fa fa-fw fa-lock"></i></a>
				<a href="snapshots"><i class="fa fa-fw fa-archive"></i></a>
			</div>
		</footer>
	</body>
</html>
