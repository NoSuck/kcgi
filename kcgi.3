.\"	$Id$
.\"
.\" Copyright (c) 2014 Kristaps Dzonsons <kristaps@bsd.lv>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: April 9 2014 $
.Dt KCGI 3
.Os
.Sh NAME
.Nm kcgi ,
.Nm khttp_parse ,
.Nm khttp_free ,
.Nm kattr ,
.Nm kbody ,
.Nm kclosure ,
.Nm kclosureto ,
.Nm kdecl ,
.Nm kelem ,
.Nm kelemsave ,
.Nm kentity ,
.Nm khead ,
.Nm kinput ,
.Nm kncr ,
.Nm ktext ,
.Nm ktemplate ,
.Nm kcalloc ,
.Nm kmalloc ,
.Nm krealloc ,
.Nm kstrdup ,
.Nm kxrealloc
.Nd minimal CGI library in C
.Sh SYNOPSIS
.In kcgi.h
.Ft void
.Fo khttp_free
.Fa "struct kreq *req"
.Fc
.Ft void
.Fo khttp_parse
.Fa "struct kreq *req"
.Fa "const struct kvalid *keys"
.Fa "size_t keysz"
.Fa "const char *const *pages"
.Fa "size_t pagesz"
.Fc
.Ft void
.Fo kattr
.Fa "struct kreq *req"
.Fa "enum kelem elem"
.Fa "..."
.Fc
.Ft void
.Fo kbody
.Fa "struct kreq *req"
.Fc
.Ft void
.Fo kclosure
.Fa "struct kreq *req"
.Fa "size_t count"
.Fc
.Ft void
.Fo kclosureto
.Fa "struct kreq *req"
.Fa "size_t pos"
.Fc
.Ft void
.Fn kdecl
.Ft "struct kreq *req"
.Fo kelem
.Fa "struct kreq *req"
.Fa "enum kelem elem"
.Fc
.Ft size_t
.Fo kelemsave
.Fa "struct kreq *req"
.Fc
.Ft void
.Fo kentity
.Fa "struct kreq *req"
.Fa "enum entity entity"
.Fc
.Ft void
.Fo khead
.Fa "struct kreq *req"
.Fa "const char *key"
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft void
.Fo kinput
.Fa "struct kreq *req"
.Fa "size_t key"
.Fc
.Ft void
.Fo kncr
.Fa "struct kreq *req"
.Fa "uint16_t ncr"
.Fc
.Ft void
.Fo ktext
.Fa "struct kreq *req"
.Fa "const char *cp"
.Fc
.Ft int
.Fo ktemplate
.Fa "const struct ktemplate *t"
.Fa "const char *fname"
.Fc
.Ft int
.Fn kvalid_double "struct kpair *kp"
.Ft int
.Fn kvalid_email "struct kpair *kp"
.Ft int
.Fn kvalid_int "struct kpair *kp"
.Ft int
.Fn kvalid_string "struct kpair *kp"
.Ft int
.Fn kvalid_udouble "struct kpair *kp"
.Ft int
.Fn kvalid_uint "struct kpair *kp"
.Ft "void *"
.Fn kcalloc "size_t nm" "size_t sz"
.Ft "void *"
.Fn kmalloc "size_t sz"
.Ft "void *"
.Fn krealloc "void *p" "size_t nm" "size_t sz"
.Ft "char *"
.Fn kstrdup "const char *cp"
.Ft "void *"
.Fn kxrealloc "void *p" "size_t sz"
.Sh DESCRIPTION
The
.Nm kcgi
library handles the CGI environment for C web applications.
Interfacing applications generally work as follows:
.Bl -enum
.It
Call
.Fn khttp_parse
as early as possible.
.It
Process input fields by examining the
.Vt "struct kpair"
elements.
.It
Emit HTTP headers with
.Fn khead ,
followed by
.Fn kbody
to begin the HTTP body.
.It
Emit HTTP body output using HTML-building functions
.Fn kattr ,
.Fn kelem ,
.Fn ktext ,
and so on; or
.It
use the
.Fn ktemplate
system.
.It
Call
.Fn khttp_free
to clean up.
.El
.Pp
The library is built around parsers for HTTP form data (cookies, GET,
and POST) with support for multipart forms.
The multipart parsing is still somewhat experimental in terms of
features, though all parsing is rigorously checked for security (e.g.,
integer overflow, binary data, etc.).
.Ss Types
The application must define the
.Vt keys
provided to
.Fn khttp_parse
as an array of 
.Vt "struct kvalid" .
It consists of the following entries:
.Bl -ohang -offset indent
.It Va "int (*valid)(struct kpair *)"
Validating function.
This can be
.Dv NULL
if anything goes.
If you provide your own
.Fa valid
function, it must set the
.Fa field
and
.Fa parsed
variables in the key-value pair.
.It Va "const char *name"
The field name, i.e., how it appears in the HTML form input name.
This cannot be
.Dv NULL .
.It Va "enum kfield field"
How to format the field value upon repopulation, i.e., 
This can be
.Dv KFIELD__MAX
if the value shouldn't be repopulated.
.\" .It Va "const char *label"
.\" Populate an HTML label element.
.\" Can be
.\" .Dv NULL
.\" if it doesn't have a label.
.\" .It Va "const char *def"
.\" Default value for population fields.
.El
.Pp
The
.Vt "struct kreq"
type is central to
.Nm kcgi .
It consists of the following fields:
.Bl -ohang -offset indent
.It Va method
The
.Dv METHOD_GET
or
.Dv METHOD_POST submission method.
Note that other methods aren't supported.
.It Va cookies
All key-value pairs read from user cookies.
.It Va cookiesz
The size of the
.Va cookies
array.
.It Va cookiemap
Entries in
.Va cookies
mapped into field indices as defined by the
.Fa keys
argument to
.Fn khttp_parse .
.It Va fields
All key-value pairs read from the POST and GET requests.
.It Va fieldsz
The number of elements in the
.Va fields
array.
.It Va fieldmap
Entries in
.Fa fields
mapped into field indices as defined by the
.Fa keys
arguments to
.Fn khttp_parse .
.It Va mime
The MIME type of the requested file as determined by its suffix.
This defaults to
.Dv MIME_HTML
if no suffix is specified.
.It Va page
The page index as defined by the
.Va pages
array passed to
.Fn khttp_parse
and parsed from the requested file.
This is the
.Em first
path component!
The default page provided to
.Fn khttp_parse
is used if no path was specified or
.Dv PATH__MAX
if the path failed lookup.
.It Va path
The path (or
.Dv NULL )
following the parsed component regardless of whether it was located in
the path array provided to
.Fn khttp_parse .
.It Va kdata
Internal data.
Should not be touched.
.It Va keys
Value passed to
.Fn khttp_parse .
.It Va keysz
Value passed to
.Fn khttp_parse .
.It Va pages
Value passed to
.Fn khttp_parse .
.It Va pagesz
Value passed to
.Fn khttp_parse .
.El
.Pp
Another central type is
.Vt "struct kpair" ,
which presents the user with fields parsed from input and (possibly)
matched to the
.Fa keys
variable passed to
.Fn http_parse .
.Bl -ohang -offset indent
.It Va key
The nil-terminated key (input) name.
.It Va val
The (input) value, which is always nil-terminated, but if the data is
binary, nil terminators may occur before the true data length of
.Fa valsz .
.It Va valsz
The true length of
.Fa val .
.It Va file
If the form provided a parsed file for the given key, this is the name
of the input file.
.It Va ctype
If the form provided a parsed file for the given key, this is the
content type (e.g.,
.Li image/jpeg )
of that file.
.It Va next
In a cookie or field map,
.Fa next
points to the next parsed key-value pair with the same
.Fa key
name.
.It Va field
If parsed, the type of data in
.Fa parsed ,
otherwise
.Dv KFIELD__MAX .
.It Va parsed
The parsed, validated value.
These may be integer, for a 64-bit signed integer; string, for a
nil-termianted character string; or double, for a double-precision
floating-point number.
.El
.Pp
The template system, driven by
.Fn ktemplate ,
uses
.Vt "struct ktemplate"
for its templating.
This consists of the following members:
.Bl -ohang -offset indent
.It Va key
An array of keys.
.It Va keysz
The number of elements in
.Va key .
.It Va arg
A pointer to pass to
.Va cb .
.It Va cb
A callback invoked when a key at position
.Fa key
is found in the
.Va key
array.
.El
.Ss Functions
The following functions initialise an HTTP request.
.Bl -ohang -offset indent
.It Fn khttp_free "struct kreq *req"
Free the memory of a context created by
.Fn khttp_parse .
.It Fn khttp_parse "struct kreq *req" \
"const struct kvalid *keys" \
"size_t keysz" \
"const char *const *pages" \
"size_t pagesz"
Fill a request
.Fa req
with input fields from the CGI environment.
Array
.Fa keys
of size
.Fa keysz
consists of input and validation fields, while
.Fa pages
of size
.Fa pagesz
is for page mapping.
.El
.Pp
The following functions create an HTML tree.
.Bl -ohang -offset indent
.It Fn kattr "struct kreq *req" "enum kelem elem" "..."
Open the scope of element
.Fa kelem
with matching key-value pairs in the varargs for its attributes.
The maximum number of nested scopes is fixed at 128.
The terminating attribute key must be
.Dv ATTR__MAX.
.It Fn kbody "struct kreq *req"
End a sequence of HTTP headers outputted with
.Fn khead .
The
.Fn khead
function must not be called after this.
.It Fn kclosure "struct kreq *req" "size_t count"
Close the last
.Fa count
scopes.
This will call
.Xr abort 3
if
.Fa count
exceeds the number of open scopes.
If
.Fa count
is zero, this will close all scopes.
.It Fn kclosureto "struct kreq *req" "size_t pos"
Close until a certain level
.Fa pos
in the HTML tree, which must be at or above the current level.
Usually used with
.Fn kelemsave .
.It Fn kdecl "struct kreq *req"
Emit the document HTML declaration.
.It Fn kelem "struct kreq *req" "enum kelem elem"
Invokes
.Fn kattr
with no attributes.
.It Fn kelemsave "struct kreq *req"
Save the current point in the HTML tree.
Useful for saving a
.Fn kclosureto
rollback point.
.It Fn kentity "struct kreq *req" "enum kentity entity"
Emit the numeric character reference for
.Va entity .
.It Fn khead "struct kreq *req" "const char *key" "const char *fmt" "..."
Emit an HTTP header
.Fa key
with value formatted by
.Fa fmt
and its variable arguments.
This occurs before any HTML functions are invoked, and must be followed
by
.Fn kbody
to indicate the start of document content.
.It Fn kinput "struct kreq *req" "size_t key"
Emit the HTML code for the input element named
.Fa key
as defined in
.Va keys
passed to
.Fn khttp_parse .
This will also fill in a value if stored in parsed
.Va fieldmap
in
.Va req .
This is meant to simplify the repopulation of fields.
.It Fn kncr "struct kreq *req" "uint16_t ncr"
Emit the numeric character reference
.Va ncr .
.It Fn ktext "struct kreq *req" "const char *cp"
Emit the text
.Va cp ,
escaping it for HTML if necessary.
.El
.Pp
The following functions are provided for the global
.Va keys
array.
.Bl -ohang -offset indent
.It Fn kvalid_double "struct kpair *kp"
Validate a double-precision floating-point number.
.It Fn kvalid_email "struct kpair *kp"
Validate an e-mail address.
.Em Note :
this is a heuristic validation, not a formal one.
.It Fn kvalid_int "struct kpair *kp"
Validate a signed 64-bit integer.
.It Fn kvalid_string "struct kpair *kp"
Validate a nil-terminated string.
This is also used by the
.Fn kvalid_double ,
.Fn kvalid_email ,
.Fn kvalid_int ,
.Fn kvalid_udouble ,
and
.Fn kvalid_uint
to make sure the string representation of their data is sane.
.It Fn kvalid_udouble "struct kpair *kp"
Validate a positive non-zero double-precision floating-point number.
.It Fn kvalid_uint "struct kpair *kp"
Validate an unsigned 64-bit natural number.
.El
.Pp
The following functions provide safe wrappers for memory allocation.
They simply call through to the standard
.Xr malloc 3 ,
.Xr calloc 3
and so on:
.Nm
does
.Em not
manage its own memory!
.Bl -ohang -offset indent
.It Fn kcalloc "size_t nm" "size_t sz"
Allocate and zero or exit on memory exhaustion.
.It Fn kmalloc "size_t sz"
Allocate or exit on memory exhaustion.
.It Fn krealloc "void *p" "size_t nm" "size_t sz"
Allocate or exit on memory allocation and discourage multiplication
overflows when multipying count by type size.
.It Fn kstrdup "const char *cp"
Allocate or exit on memory exhaustion.
.It Fn kxrealloc "void *p" "size_t sz"
Allocate or exit on memory exhaustion.
.El
.Pp
The
.Nm
library also has a simple, light-weight template system.
This is coordinated entirely by a single function,
.Fn ktemplate "struct ktemplate *t" "const char *fname" .
This function memory-maps the file
.Fa fname
and appends it to the output stream.
Whenever a key is located, where keys are delimited as
.Li @@KEY@@
in
.Fa fname ,
it is looked up in the
.Fa t
key array.
If found, the callback is invoked with the key index and the optional
argument.
Callbacks may continue to process, emit HTML trees, and so on.
.Sh EXAMPLES
A simple example exists in
.Pa @DATADIR@/sample.c .
It illustrates templating, form handling, and so on.
.Sh AUTHORS
The
.Nm
library was written by
.An Kristaps Dzonsons Aq Mt kristaps@bsd.lv .
