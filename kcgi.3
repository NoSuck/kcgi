.\"	$Id$
.\"
.\" Copyright (c) 2014 Kristaps Dzonsons <kristaps@bsd.lv>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: July 5 2014 $
.Dt KCGI 3
.Os
.Sh NAME
.Nm kcgi ,
.Nm khttp_body ,
.Nm khttp_free ,
.Nm khttp_head ,
.Nm khttp_parse ,
.Nm khttp_parsex ,
.Nm khttp_putc ,
.Nm khttp_puts ,
.Nm khttp_template ,
.Nm khttp_template_buf ,
.Nm khttp_write ,
.Nm khtml_attr ,
.Nm khtml_attrx ,
.Nm khtml_close ,
.Nm khtml_closeto ,
.Nm khtml_double ,
.Nm khtml_elem ,
.Nm khtml_elemat ,
.Nm khtml_entity ,
.Nm khtml_int ,
.Nm khtml_ncr ,
.Nm khtml_text ,
.Nm kasprintf ,
.Nm kcalloc ,
.Nm kmalloc ,
.Nm krealloc ,
.Nm kreallocarray ,
.Nm kstrdup ,
.Nm kutil_invalidate ,
.Nm kutil_urlabs ,
.Nm kutil_urlpart ,
.Nm kutil_urlencode ,
.Nm kvalid_date ,
.Nm kvalid_double ,
.Nm kvalid_email ,
.Nm kvalid_int ,
.Nm kvalid_string ,
.Nm kvalid_stringne ,
.Nm kvalid_udouble ,
.Nm kvalid_uint
.Nd minimal CGI library in C
.Sh LIBRARY
.Lb libkcgi
.Sh SYNOPSIS
.In kcgi.h
.Ft void
.Fo khttp_body
.Fa "struct kreq *req"
.Fc
.Ft void
.Fo khttp_free
.Fa "struct kreq *req"
.Fc
.Ft void
.Fo khttp_head
.Fa "struct kreq *req"
.Fa "const char *key"
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft int
.Fo khttp_parse
.Fa "struct kreq *req"
.Fa "const struct kvalid *keys"
.Fa "size_t keysz"
.Fa "const char *const *pages"
.Fa "size_t pagesz"
.Fc
.Ft int
.Fo khttp_parsex
.Fa "struct kreq *req"
.Fa "const struct kmimemap *suffixes"
.Fa "size_t mimemax"
.Fa "const struct kvalid *keys"
.Fa "size_t keysz"
.Fa "const char *const *pages"
.Fa "size_t pagesz"
.Fa "void *arg"
.Fa "void (*argfree)(void *arg)"
.Fc
.Ft void
.Fo khttp_putc
.Fa "struct kreq *req"
.Fa "int c"
.Fc
.Ft void
.Fo khttp_puts
.Fa "struct kreq *req"
.Fa "const char *cp"
.Fc
.Ft int
.Fo khttp_template
.Fa "struct kreq *req"
.Fa "const struct ktemplate *t"
.Fa "const char *fname"
.Fc
.Ft int
.Fo khttp_template_buf
.Fa "struct kreq *req"
.Fa "const struct ktemplate *t"
.Fa "const char *buf"
.Fa "size_t sz"
.Fc
.Ft void
.Fo khttp_write
.Fa "struct kreq *req"
.Fa "const void *buf"
.Fa "size_t sz"
.Fc
.Ft void
.Fo khtml_attr
.Fa "struct kreq *req"
.Fa "enum kelem elem"
.Fa "..."
.Fc
.Ft void
.Fo khtml_attrx
.Fa "struct kreq *req"
.Fa "enum kelem elem"
.Fa "..."
.Fc
.Ft void
.Fo khtml_close
.Fa "struct kreq *req"
.Fa "size_t count"
.Fc
.Ft void
.Fo khtml_closeto
.Fa "struct kreq *req"
.Fa "size_t pos"
.Fc
.Ft void
.Fo khtml_double
.Fa "struct kreq *req"
.Fa "double val"
.Fc
.Ft size_t
.Fo khtml_elemat
.Fa "struct kreq *req"
.Fc
.Ft void
.Fo khtml_entity
.Fa "struct kreq *req"
.Fa "enum entity entity"
.Fc
.Ft void
.Fo khtml_int
.Fa "struct kreq *req"
.Fa "int64_t val"
.Fc
.Ft void
.Fo khtml_ncr
.Fa "struct kreq *req"
.Fa "uint16_t ncr"
.Fc
.Ft void
.Fo khtml_text
.Fa "struct kreq *req"
.Fa "const char *cp"
.Fc
.Ft int
.Fn kvalid_date "struct kpair *kp"
.Ft int
.Fn kvalid_double "struct kpair *kp"
.Ft int
.Fn kvalid_email "struct kpair *kp"
.Ft int
.Fn kvalid_int "struct kpair *kp"
.Ft int
.Fn kvalid_string "struct kpair *kp"
.Ft int
.Fn kvalid_stringne "struct kpair *kp"
.Ft int
.Fn kvalid_udouble "struct kpair *kp"
.Ft int
.Fn kvalid_uint "struct kpair *kp"
.Ft int
.Fn kasprintf "char **p" "const char *fmt" "..."
.Ft "void *"
.Fn kcalloc "size_t nm" "size_t sz"
.Ft "void *"
.Fn kmalloc "size_t sz"
.Ft "void *"
.Fn krealloc "void *p" "size_t sz"
.Ft "void *"
.Fn kreallocarray "void *p" "size_t nm" "size_t sz"
.Ft "char *"
.Fn kstrdup "const char *cp"
.Ft void
.Fn kutil_invalidate "struct kreq *req" "struct kpair *kp"
.Ft "char *"
.Fo kutil_urlabs
.Fa "enum kscheme scheme"
.Fa "const char *host"
.Fa "uint16_t port"
.Fa "const char *path"
.Fc
.Ft "char *"
.Fo kutil_urlpart
.Fa "struct kreq *req"
.Fa "const char *path"
.Fa "const char *suffix"
.Fa "const char *page"
.Fa "..."
.Fc
.Ft "char *"
.Fn kutil_urlencode "const char *cp"
.Sh DESCRIPTION
The
.Nm kcgi
library handles the CGI environment for C web applications.
Interfacing applications generally work as follows:
.Bl -enum
.It
Call
.Fn khttp_parse
as early as possible.
This will parse and validate input fields and cookies with
.Fn kvalid_date ,
.Fn kvalid_double ,
.Fn kvalid_email ,
.Fn kvalid_int ,
.Fn kvalid_string ,
.Fn kvalid_stringne ,
.Fn kvalid_udouble ,
.Fn kvalid_uint ,
and/or those provided by the implementing system.
It also sets up the HTTP environment: compression, paths, and so on.
.It
Process input fields by examining the
.Vt "struct kpair"
elements.
If you want to perform a high-level or un-sandboxed revalidation, as
.Fn khttp_parse
operates within a sandbox, use
.Fn kutil_invalidate
to keep parsed fields properly set.
.It
Emit HTTP headers with
.Fn khttp_head ,
followed by
.Fn khttp_body
to begin the HTTP body.
.It
Emit HTTP body output using HTML-building functions
.Fn khtml_attr ,
.Fn khtml_attrx ,
.Fn khtml_close ,
.Fn khtml_closeto ,
.Fn khtml_double ,
.Fn khtml_elem ,
.Fn khtml_elemat ,
.Fn khtml_entity ,
.Fn khtml_int ,
.Fn khtml_ncr
and
.Fn khtml_text ;
or
.It
use the
.Fn khttp_template
or
.Fn khttp_template_buf
system; or
.It
use
.Fn khttp_putc ,
.Fn khttp_puts ,
and
.Fn khttp_write
for non-HTML media.
.Em \&Do not
use
.Xr printf 3
or other functions to append to standard output:
.Nm kcgi
will automatically compress output if requested by the client, and
overriding the output stream will circumvent this behaviour and might
mix compressed and uncompressed data.
.It
Call
.Fn khttp_free
to clean up.
.El
.Pp
The
.Nm
library is built around the
.Fn khttp_parse
sandboxed parsers for HTTP form data (cookies, GET, and POST) with
support for
multipart (mixed and form-data), url-encoded, and plain forms.
All parsing is rigorously checked for security (e.g., integer overflow,
binary data, etc.).
.Pp
To compile applications with
.Nm ,
make sure
.Pa kcgi.h
is in the header path and
.Pa libkcgi.a
in the library path, then link with
.Fl Ar lkcgi
and
.Fl Ar lz
.Pq unless compression has been disabled at compile-time .
For example,
.Bd -literal
% cc -I/usr/local/include -c -o sample.o sample.c
% cc -L/usr/local/lib -o sample -lkcgi -lz
.Ed
.Ss Globals
There are several convenience variables defined in
.Pa kcgi.h .
They are as follows:
.Bl -ohang -offset indent
.It Va ksuffixmap
A reverse map of all suffixes mapped to a particular
.Vt "enum kmime" .
This, like
.Va ksuffixes
and
.Va kmimetypes ,
provide a set of default MIME entries for use by interfacing
applications.
.It Va ksuffixes
An array of common file suffixes mapped to
.Vt "enum kmime"
MIME types.
.It Va kresps
HTTP response headers.
These may be indexed via
.Vt "enum kresp"
fields.
.It Va kmimetypes
An array of common MIME type IANA names used when populating the
.Li Content-Type
HTTP header.
These can be looked up using
.Vt "enum kime"
in the array.
Application will generally set the
.Li Content-Type
from the
.Va mime
field of
.Vt "struct kreq" .
.It Va khttps
An array of HTTP status code strings looked up using
.Vt "enum khttp" .
.El
.Ss Types
The
.Vt "struct kreq"
type is central to
.Nm kcgi .
It consists of the following fields:
.Bl -ohang -offset indent
.It Va arg
Private application data.
This is set during
.Fn khttp_parse .
.It Va method
The
.Dv KMETHOD_GET
or
.Dv KMETHOD_POST
submission method.
Note that other methods aren't supported.
.It Va auth
Type of HTTP authorisation, if any.
If an authorisation is specified but with unknown type (i.e., not digest
or basic authentiation), this is set to
.Dv KAUTH_UNKNOWN .
.It Va cookies
All key-value pairs read from user cookies.
.It Va cookiesz
The size of the
.Va cookies
array.
.It Va cookiemap
Entries in successfully-parsed (or un-parsed)
.Va cookies
mapped into field indices as defined by the
.Fa keys
argument to
.Fn khttp_parse .
.It Va cookienmap
Entries in unsuccessfully-parsed (but still attempted)
.Fa cookies
mapped into field indices as defined by the
.Fa keys
argument to
.Fn khttp_parse .
.It Va fields
All key-value pairs read from the POST and GET requests.
.It Va fieldsz
The number of elements in the
.Va fields
array.
.It Va fieldmap
Entries in successfully-parsed (or un-parsed)
.Fa fields
mapped into field indices as defined by the
.Fa keys
arguments to
.Fn khttp_parse .
.It Va fieldnmap
Entries in unsuccessfully-parsed (but still attempted)
.Fa fields
mapped into field indices as defined by the
.Fa keys
argument to
.Fn khttp_parse .
.It Va mime
The MIME type of the requested file as determined by its
.Pa suffix
matched to the
.Fa mimemap
map passed to
.Fn khttp_parsex
or the default
.Va kmimemap
if using
.Fn khttp_parse .
This defaults to the
.Va mimemax
value passed to
.Fn khttp_parsex
or the default
.Dv KMIME__MAX
if using
.Fn khttp_parse .
when no suffix is specified or when the suffix is specified but not known.
.It Va page
The page index as defined by the
.Va pages
array passed to
.Fn khttp_parse
and parsed from the requested file.
This is the
.Em first
path component!
The default page provided to
.Fn khttp_parse
is used if no path was specified or
.Fa pagesz
if the path failed lookup.
.It Va path
The path (or
.Dv NULL )
following the parsed component regardless of whether it was located in
the path array provided to
.Fn khttp_parse .
For example, if the
.Dv PATH_INFO
is
.Pa foo.cgi/bar/baz.html ,
the path component would be
.Pa baz
.Pq with the leading slash stripped .
.It Va suffix
The suffix part of the
.Dv PATH_INFO
or
.Dv NULL
if none exists.
For example, if the
.Dv PATH_INFO
is
.Pa foo.cgi/bar/baz.html ,
the suffix would be
.Pa html .
See the
.Va mime
field for the MIME type parsed from the suffix.
.It Va fullpath
The full path following the server name or
.Dv NULL
if there is no path following the server.
For example, if
.Pa foo.cgi/bar/baz
is the
.Dv PATH_INFO ,
this would be
.Pa /bar/baz .
.It Va remote
The string form of the client's IPV4 or IVP6 address.
.It Va host
The host-name request passed to the application.
.It Va port
The server's receiving TCP port.
.It Va kdata
Internal data.
Should not be touched.
.It Va keys
Value passed to
.Fn khttp_parse .
.It Va keysz
Value passed to
.Fn khttp_parse .
.It Va pname
The script name (which may be an empty string in degenerate cases).
.El
.Pp
The application must define the
.Vt keys
provided to
.Fn khttp_parse
as an array of
.Vt "struct kvalid" ,
which consists of the following:
.Bl -ohang -offset indent
.It Va "int (*valid)(struct kpair *kp)"
Validating function.
This can be
.Dv NULL
if anything goes.
If you provide your own
.Fa valid
function, it must set the
.Va field
and
.Va parsed
variables in the key-value pair.
You can also allocate new memory for the
.Va val
and thus
.Va valsz :
if the value of
.Va val
changes during your validation, the new value will be freed with
.Xr free 3
after being passed out of the sandbox.
.Em Note :
these functions are invoked from within a system-specific sandbox.
You should assume that you cannot invoke any
.Qq invasive
system calls such as opening files, sockets, etc.
In other words, these must be pure computation.
.It Va "const char *name"
The field name, i.e., how it appears in the HTML form input name.
This cannot be
.Dv NULL .
.El
.Pp
The
.Vt "struct kpair"
structure presents the user with fields parsed from input and (possibly)
matched to the
.Fa keys
variable passed to
.Fn http_parse .
.Bl -ohang -offset indent
.It Va key
The nil-terminated key (input) name.
.It Va val
The (input) value, which is always nil-terminated, but if the data is
binary, nil terminators may occur before the true data length of
.Fa valsz .
.It Va valsz
The true length of
.Fa val .
.It Va file
The value's source filename or
.Dv NULL
if not defined.
.It Va ctype
The value's content type (e.g.,
.Li image/jpeg ) ,
or
.Dv NULL
if not defined.
.It Va ctypepos
If
.Va ctype
is not
.Dv NULL ,
it is looked up in the
.Fa mimes
parameter passed to
.Fn khttp_parsex
or
.Va ksuffixmap
if using
.Fn khttp_parse .
If found, it is set to the appropriate index.
Otherwise, it's
.Fa mimesz .
.It Va xcode
The value's content transfer encoding (e.g.,
.Li base64 ) ,
or
.Dv NULL
if not defined.
.It Va next
In a cookie or field map,
.Fa next
points to the next parsed key-value pair with the same
.Fa key
name.
.It Va keypos
If looked up in the
.Fa keys
variable passed to
.Fn khttp_parse ,
the index of the looked-up key.
Otherwise
.Fa keysz .
.It Va state
The validation state: whether validated by a parse, invalidated by a
parse, or non-validated (unparsed).
.It Va type
If parsed, the type of data in
.Fa parsed ,
otherwise
.Dv KFIELD__MAX .
.It Va parsed
The parsed, validated value.
These may be integer, for a 64-bit signed integer; string, for a
nil-termianted character string; or double, for a double-precision
floating-point number.
.El
.Pp
The template system, driven by
.Fn khttp_template
and
.Fn khttp_template_buf ,
uses
.Vt "struct ktemplate"
for its templating.
This consists of the following members:
.Bl -ohang -offset indent
.It Va key
An array of keys.
If a key consists of
.Li foo ,
it is parsed from the template input file as
.Li @@foo@@ .
.It Va keysz
The number of elements in
.Va key .
.It Va arg
A pointer to pass to
.Va cb .
.It Va cb
A callback invoked when a key at position
.Fa key
is found in the
.Va key
array.
Again, keys such as
.Li foo
appear in the template input file as
.Li @@foo@@ .
.El
.Ss Functions
The following functions initialise an HTTP request.
.Bl -ohang -offset indent
.It Fn khttp_body "struct kreq *req"
End a sequence of HTTP headers outputted with
.Fn khttp_head .
The
.Fn khttp_head
function may not be called after this.
This function will append the
.Li Content-Encoding
HTTP parameter with compression support if the request specifies it,
unless allocation of the compression space fails.
If appended, all subsequent output will be compressed with
.Xr zlib 3 .
.It Fn khttp_free "struct kreq *req"
Free the memory of a context created by
.Fn khttp_parse
and, if applicable, closes the compressed output stream opened by
.Fn khttp_body .
.It Fn khttp_head "struct kreq *req" "const char *key" "const char *fmt" "..."
Emit an HTTP header
.Fa key
with value formatted by
.Fa fmt
and its variable arguments.
This occurs before any HTML functions are invoked.
The sequence of
.Fn khttp_head
calls, if any, must be followed by a mandatory
.Fn khttp_body
to indicate the start of document content.
You may not invoke
.Fn khttp_head
subsequent to
.Fn khttp_body .
Most HTTP response headers are included in the
.Va kresps
global array.
.It Fn khttp_parse "struct kreq *req" \
"const struct kvalid *keys" \
"size_t keysz" \
"const char *const *pages" \
"size_t pagesz"
A shortened version of
.Fn khttp_parsex
defaulting to
.Va ksuffixmap ,
.Va kmimetypes ,
and
.Dv KMIME__MAX .
It also passes
.Dv NULL
arguments for the private data and free function.
.It Fn khttp_parsex "struct kreq *req" \
"const struct kmimemap *suffixes" \
"size_t mimemax" \
"const struct kvalid *keys" \
"size_t keysz" \
"const char *const *pages" \
"size_t pagesz" \
"void *arg" \
"void (*argfree)(void *arg)"
Fill a request
.Fa req
with input fields from the CGI environment.
Array
.Fa keys
of size
.Fa keysz
consists of input and validation fields, while
.Fa pages
of size
.Fa pagesz
is for page mapping and
.Fa suffixes
for MIME type (suffix) mapping with unknown MIME type
.Fa maxmime .
.Pp
The
.Fa arg
pointer is private application data.
It is not touched by
.Nm kcgi
unless
.Fa argfree
is provided, in which case
.Fa argfree
is invoked with
.Fa arg
by the child process started to parse untrusted network data.
This makes sure that no unnecessary data is leaked into the child.
.Pp
If
.Fn khttp_parse
fails (due to lack of memory, or underlying parse errors) it returns
0, else it returns 1.
If it returns 0, you should exit your application immediately.
.El
.Pp
The following functions create an HTML tree.
None of these functions may be called before
.Fn khttp_body .
.Bl -ohang -offset indent
.It Fn khtml_attr "struct kreq *req" "enum kelem elem" "..."
Open the scope of element
.Fa elem
with matching key-value pairs in the varargs for its attributes.
The maximum number of nested scopes is fixed at 128.
The terminating attribute key must be
.Dv ATTR__MAX.
.It Fn khtml_attrx "struct kreq *req" "enum kelem elem" "..."
Like
.Fn khtml_attr ,
but accepts an addition parameter
.Ft "enum attrx"
following the
.Ft "enum attr"
that specifies the attribute type.
This is useful for non-string attributes, for example, invoking with
.Dv KATTR_WIDTH ,
.Dv KATTRX_INT ,
and
.Li 100
will properly render the integer type.
The types route through to
.Fn khtml_text
for
.Dv KATTRX_STRING ,
.Fn khtml_int
for
.Dv KATTRX_INT ,
.Fn khtml_double
for
.Dv KATTRX_DOUBLE .
.It Fn khtml_close "struct kreq *req" "size_t count"
Close the last
.Fa count
scopes.
This will call
.Xr abort 3
if
.Fa count
exceeds the number of open scopes.
If
.Fa count
is zero, this will close all scopes.
.Em \&Do not
close HTML
.Qq void
elements such as
.Aq meta .
.It Fn khtml_closeto "struct kreq *req" "size_t pos"
Close until a certain level
.Fa pos
in the HTML tree, which must be at or above the current level.
Usually used with
.Fn khtml_elemat .
.It Fn khtml_double "struct kreq *req" "double val"
Wrapper over
.Fn khtml_text
for formatting a double-precision floating point.
This uses a buffer of size
.Li 256
and the
.Li %g
to
.Xr snprintf 3 ,
which may not be what you want.
.It Fn khtml_elem "struct kreq *req" "enum kelem elem"
Invokes
.Fn khtml_attr
with no attributes.
.It Fn khtml_elemat "struct kreq *req"
Save the current point in the HTML tree.
Useful for saving a
.Fn khtml_closeto
rollback point.
.It Fn khtml_entity "struct kreq *req" "enum kentity entity"
Emit the numeric character reference for
.Va entity .
.It Fn khtml_int "struct kreq *req" "int64_t val"
Wrapper over
.Fn khtml_text
for formatting a 64-bit signed integer.
.It Fn khtml_ncr "struct kreq *req" "uint16_t ncr"
Emit the numeric character reference
.Va ncr .
.It Fn khtml_text "struct kreq *req" "const char *cp"
Emit the text
.Va cp ,
escaping it (e.g.,
.Sq \&> )
for HTML if necessary.
.El
.Pp
If your application puts data directly into the HTTP body without HTML
escaping, use the following functions:
.Bl -ohang -offset indent
.It Fn khttp_putc "struct kreq *req" "int c"
Append a single character
.Fa c
to the output stream.
.It Fn khttp_puts "struct kreq *req" "const char *cp"
Append a nil-terminated string
.Fa cp
to the output stream.
.It Fn khttp_write "struct kreq *req" "const void *buf" "size_t sz"
Append a (possibly) binary buffer
.Fa buf
of length
.Fa sz
to the output stream.
.El
.Pp
The following functions are provided for the global
.Va keys
array.
.Bl -ohang -offset indent
.It Fn kvalid_date "struct kpair *kp"
Validate a date in ISO 8601
.Li YYYY-MM-DD
format.
Returned as the number of seconds since the UNIX epoch, 1970-01-01.
.It Fn kvalid_double "struct kpair *kp"
Validate a double-precision floating-point number.
.Em Note :
this uses the current locale via
.Xr strtod 3 .
.It Fn kvalid_email "struct kpair *kp"
Validate an e-mail address.
.Em Note :
this is a heuristic validation, not a formal one.
.It Fn kvalid_int "struct kpair *kp"
Validate a signed 64-bit integer.
.It Fn kvalid_string "struct kpair *kp"
Validate a nil-terminated string.
.Em Note :
the string may be zero-length!
.It Fn kvalid_stringne "struct kpair *kp"
Same as
.Fn kvalid_string ,
but ensures that the string is non-empty.
.It Fn kvalid_udouble "struct kpair *kp"
Validate a positive non-zero double-precision floating-point number.
.Em Note :
this uses the current locale via
.Xr strtod 3 .
.It Fn kvalid_uint "struct kpair *kp"
Validate an unsigned 64-bit natural number greater than or equal to 0.
.El
.Pp
The following functions provide safe wrappers for memory allocation.
They simply call through to the standard
.Xr malloc 3 ,
.Xr calloc 3
and so on:
.Nm
does
.Em not
manage its own memory!
These functions never return
.Dv NULL .
.Bl -ohang -offset indent
.It Fn kasprintf "char **p" "const char *fmt" "..."
Allocate as with
.Xr asprintf 3 ,
but exit on memory exhaustion.
.It Fn kcalloc "size_t nm" "size_t sz"
Allocate and zero as with
.Xr calloc 3 ,
but exit on memory exhaustion.
.It Fn kmalloc "size_t sz"
Allocate as with
.Xr malloc 3 ,
but exit on memory exhaustion.
.It Fn kreallocarray "void *p" "size_t nm" "size_t sz"
Allocate as with
.Xr reallocarray 3 ,
but exit on memory allocation and discourage multiplication overflows
when multipying count by type size.
.It Fn kstrdup "const char *cp"
Allocate as with
.Xr strdup 3 ,
but exit on memory exhaustion.
.It Fn krealloc "void *p" "size_t sz"
Allocate as with
.Xr realloc 3 ,
but exit on memory exhaustion.
.El
.Pp
The
.Nm
library also has a simple, light-weight template system.
This is coordinated entirely by two related functions:
.Bl -ohang -offset indent
.It Fn khttp_template "struct kreq *req" "struct ktemplate *t" "const char *fname"
This function memory-maps the file
.Fa fname
and appends it to the output stream.
Whenever a key is located, where a key named
.Li key
would be written in
.Li @@key@@ ,
it is looked up in the
.Fa t
key array.
If found, the callback is invoked with the key index and the optional
argument.
Callbacks may continue to process, emit HTML trees, and so on.
.It Fn khttp_template_buf "struct kreq *req" "struct ktemplate *t" \
"const char *buf" "size_t sz"
Like
.Fn khttp_template ,
but accepting a (possibly binary) buffer and its length.
.El
.Pp
Several convenience functions are also provided for managing HTTP and
HTML concepts.
.Bl -ohang -offset indent
.It Fn kutil_invalidate "struct kreq *req" "struct kpair *kp"
Mark a validated input field
.Fa kp
as invalidate.
If the input field is not valid, this function does nothing.
.It Fn kutil_urlencode "const char *cp"
Return a dynamically-allocated URL-encoded string or
.Dv NULL
if
.Fa cp
is
.Dv NULL
and/or memory allocation fails.
The caller must free the string with
.Xr free 3 .
.It Fn kutil_urlabs "enum kscheme scheme" \
"const char *host" "uint16_t port" "const char *path"
Return a dynamically-allocated absolute URL with scheme
.Fa scheme ,
domain
.Fa host ,
port
.Fa port ,
and path part (including query string, etc.)
.Fa path .
This
.Em is not
URL-encoded in any way, so make sure to use
.Fn kutil_urlpart
or just
.Fn kutil_urlencode
for the sensitive parts.
The caller must free the string with
.Xr free 3 .
The function will exit on memory exhaustion.
.It Fn kutil_urlpart "struct kreq *req" "const char *path" \
"const char *mime" "const char *page" "..."
Return a dynamically-allocated partial URL, meaning just the path component,
filename, MIME suffix, and optionally key-value query string pairs.
The variable arguments refer to input keys and values, both
nil-terminated character pointers.
This variable array must be terminated with a
.Dv NULL .
The caller must free the string with
.Xr free 3 .
The function will exit on memory exhaustion.
.El
.Sh EXAMPLES
A simple example exists in
.Pa @DATADIR@/sample.c .
It illustrates templating, form handling, and so on.
.Sh STANDARDS
Many standards are involved in the
.Nm
library, most generally being draft RFC 3875,
.Qq The Common Gateway Interface (CGI) Version 1.1 .
.Bl -bullet
.It
HTML5 compatible with the draft standard of February 2014.
.It
The partial multipart form data support is defined by RFC 2388,
.Qq Returning Values from Forms: multipart/form-data ,
which is further defined by RFCs 2045 and 2046,
.Qq Multipurpose Internet Mail Extensions .
.It
MIME type names are registered with IANA.
.It
URLs are formatted according to RFC 1630,
.Qq Universal Resource Identifiers in WWW .
.It
HTTP response headers are standardised in RFC 2616,
.Qq HTTP/1.1
and further in RFC 4229,
.Qq HTTP Header Field Registrations .
.It
Permanent URI schemes are registered with IANA.
.El
.Sh AUTHORS
The
.Nm
library was written by
.An Kristaps Dzonsons Aq Mt kristaps@bsd.lv .
